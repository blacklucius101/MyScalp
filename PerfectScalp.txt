#property strict
#include <Trade\Trade.mqh> // Include the CTrade class for trade operations

//+------------------------------------------------------------------+
//|                                                 PerfectScalp.mq5 |
//|                        Copyright 2023, AI Generated EA           |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
/*
Purpose:
The PerfectScalp Expert Advisor (EA) is designed for scalping strategies.
It aims to identify entry points based on a combination of:
1. Retracement from a high/low identified by the Single_Level_ZZ_Semafor indicator.
2. Confirmation from the ComboTSI_Stoch indicator (strong or weak signals).
3. Further confirmation from the MACD-2-Cloud-Cross indicator (buy/sell state or crossover).

IMPORTANT: Indicator buffer indices and logic for `Single_Level_ZZ_Semafor.mq5` and `ComboTSI_Stoch.mq5` are based on their provided source files. MACD logic uses the standard built-in iMACD indicator.
*/

//+------------------------------------------------------------------+
//| EA Properties                                                    |
//+------------------------------------------------------------------+
#property copyright "AI Generated EA"
#property link      "https://www.mql5.com"
#property version   "1.00"
#property description "PerfectScalp EA: Enters on Semafor retracement, TSI, and MACD confirmation."

//+------------------------------------------------------------------+
//| Input Parameters                                                 |
//+------------------------------------------------------------------+
//--- Entry Logic
input group "Entry Logic"
input double InpRetracementPercent = 61.8; // Retracement Percentage of Previous Candle Range
enum ENUM_COMBO_TSI_SIGNAL_TYPE
  {
   Strong_Only,      // Strong Only
   Strong_And_Weak   // All (Strong & Weak)
  };
input ENUM_COMBO_TSI_SIGNAL_TYPE InpComboTSISignalType = Strong_And_Weak; // ComboTSI Signal Type

//--- Trade Management
input group "Trade Management"
input int    InpStopLossPoints = 70000;    // Stop Loss in Points (0 = disabled)
input int    InpTakeProfitPoints = 5000;   // Take Profit in Points (0 = disabled)
input double InpLotSize = 0.0;        // Lot Size (0.0 = Dynamic)
input ulong  InpMagicNumber = 12345;  // Magic Number for trades

//--- Indicator Names/Paths
input group "Indicator Configuration"
input string InpSemaforIndicatorName = "Custom\\Single_Level_ZZ_Semafor"; // Semafor Indicator Name/Path
input string InpComboTSIIndicatorName = "Custom\\ComboTSI_Stoch";       // ComboTSI Indicator Name/Path
// input string InpMACDCloudIndicatorName = "MACD-2-Cloud-Cross"; // MACD Cloud Indicator Name/Path - Removed

input group "Standard MACD Settings"
input int InpMacdFastEMA = 12;           // Standard MACD: Fast EMA Period
input int InpMacdSlowEMA = 26;           // Standard MACD: Slow EMA Period
input int InpMacdSignalSMA = 9;            // Standard MACD: Signal SMA Period
input ENUM_APPLIED_PRICE InpMacdAppliedPrice = PRICE_CLOSE; // Standard MACD: Applied Price

//+------------------------------------------------------------------+
//| Signal Data Structure and Instances                              |
//+------------------------------------------------------------------+
struct SignalData {
   datetime candleTime;     // Time of the signal candle
   double triggerPrice;     // Price where arrow appeared (high for bearish, low for bullish)
   double thresholdPrice;   // Calculated threshold price for entry
   bool signalUsed;         // Flag if signal has been used
   double candleRange;      // Range of the signal candle (high-low)
};

// Global static instances for bullish and bearish signals
static SignalData psArrowBullish;
static SignalData psArrowBearish;

// Helper to reset signal data
void ResetSignalData(SignalData &data)
{
   data.candleTime = 0;
   data.triggerPrice = 0;
   data.thresholdPrice = 0;
   data.signalUsed = false;
   data.candleRange = 0;
}

//+------------------------------------------------------------------+
//| Global Variables and Constants                                   |
//+------------------------------------------------------------------+
//--- Indicator Handles
int hSemafor;
int hComboTSI;
// int hMACDCloud; // Removed
int hStandardMACD; // Handle for standard MACD indicator

//--- Trade State Variables
bool   hasTradedThisBar;    // Flag to prevent multiple trades in the same bar after a Semafor signal
// Removed semaforBarIndex, semaforPriceLevel, prevCandleRange as they are now part of SignalData struct

//--- New Bar Detection
datetime lastBarOpenTime;   // Stores the open time of the last processed bar to detect new bars

/*
//--- Indicator Buffer Constants - USER VERIFICATION REQUIRED!
// These constants define which buffer index is used to read data from custom indicators.
// Please verify these against the Data Window in MetaTrader 5 for each indicator.
// To do this:
// 1. Add the custom indicator to a chart.
// 2. Open the Data Window (View -> Data Window or Ctrl+D).
// 3. Hover your mouse over the indicator lines/arrows on the chart.
// 4. The Data Window will show the indicator's plotted values and their corresponding buffer numbers.
//    Adjust the constants below if they don't match what you see for the signals.
*/
// Single_Level_ZZ_Semafor
const int SEMAFOR_BUY_ARROW_BUFFER = 0;  // Buffer for Buy (up) arrow/dot. Value is Low price of semafor bar, or 0.0 if no signal.
const int SEMAFOR_SELL_ARROW_BUFFER = 1; // Buffer for Sell (down) arrow/dot. Value is High price of semafor bar, or 0.0 if no signal.

// ComboTSI_Stoch
const int COMBOTSI_SIGNAL_BUFFER = 5; // Buffer for combined TSI+Stoch signal. Values: 0(SBull), 1(SBear), 2(WBull), 3(WBear), -1(None).

// MACD-2-Cloud-Cross - Removed, will use iMACD
// const int MACD_CROSSOVER_STATE_BUFFER = 2; // Buffer for MACD Crossover State. Values: 1(BullishCross), -1(BearishCross), 0(None).

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   ResetSignalData(psArrowBullish);
   ResetSignalData(psArrowBearish);

   //--- Initialize global variables
   hasTradedThisBar = false;
   // Removed semaforBarIndex, semaforPriceLevel, prevCandleRange initializations
   lastBarOpenTime = 0;

   //--- Load Custom Indicators
   // Semafor Indicator
   hSemafor = iCustom(NULL, 0, InpSemaforIndicatorName);
   if(hSemafor == INVALID_HANDLE)
     {
      PrintFormat("Error loading Semafor indicator '%s'. Check name/path in input parameters. Error: %d", InpSemaforIndicatorName, GetLastError());
      return(INIT_FAILED);
     }

   // ComboTSI Stoch Indicator
   hComboTSI = iCustom(NULL, 0, InpComboTSIIndicatorName);
   if(hComboTSI == INVALID_HANDLE)
     {
      PrintFormat("Error loading ComboTSI Stoch indicator '%s'. Check name/path in input parameters. Error: %d", InpComboTSIIndicatorName, GetLastError());
      return(INIT_FAILED);
     }

   // MACD Cloud Indicator - Removed custom indicator loading
   // hMACDCloud = iCustom(NULL, 0, InpMACDCloudIndicatorName);
   // if(hMACDCloud == INVALID_HANDLE)
   //   {
   //    PrintFormat("Error loading MACD Cloud indicator '%s'. Check name/path in input parameters. Error: %d", InpMACDCloudIndicatorName, GetLastError());
   //    return(INIT_FAILED);
   //   }

   // Standard MACD Indicator
   hStandardMACD = iMACD(_Symbol, _Period, InpMacdFastEMA, InpMacdSlowEMA, InpMacdSignalSMA, InpMacdAppliedPrice);
   if(hStandardMACD == INVALID_HANDLE)
     {
      PrintFormat("Error loading standard iMACD indicator. Error: %d", GetLastError());
      return(INIT_FAILED);
     }

   Print("PerfectScalp EA initialized successfully. All indicators loaded.");
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
   //--- Release indicator handles
   if(hSemafor != INVALID_HANDLE) IndicatorRelease(hSemafor);
   if(hComboTSI != INVALID_HANDLE) IndicatorRelease(hComboTSI);
   // if(hMACDCloud != INVALID_HANDLE) IndicatorRelease(hMACDCloud); // Removed
   if(hStandardMACD != INVALID_HANDLE) IndicatorRelease(hStandardMACD);

   //--- Clean up all EA-specific graphical objects
   // Iterate through all objects on the chart and delete those created by this EA
   for(int i = ObjectsTotal(0, -1, -1) - 1; i >= 0; i--) // Check all object types in the main window
     {
      string objName = ObjectName(0, i, -1, -1);
      if(StringFind(objName, "PS_Line_") == 0) // Check if the object name starts with our prefix
        {
         ObjectDelete(0, objName);
        }
     }
   
   //--- Clear any comment from the chart
   Comment(""); 
   
   //--- Print deinitialization message with reason
   PrintFormat("PerfectScalp EA deinitialized. Reason code: %d (Refer to MQL5 docs for REASON_# codes)", reason);
  }
//+------------------------------------------------------------------+
//| Helper function to get lot size decimal places                   |
//+------------------------------------------------------------------+
int GetLotDigits()
  {
   double lot_step = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if(lot_step == 0.1) return(1);
   if(lot_step == 0.01) return(2);
   if(lot_step == 0.001) return(3);
   // Default for safety, though most brokers use 0.1, 0.01, or 0.001
   return(2);
  }
//+------------------------------------------------------------------+
//| Process New Bar Signals                                          |
//+------------------------------------------------------------------+
void ProcessNewBarSignals()
{
   MqlRates rates[1]; // Need rates for candle 1 (previous, semafor) - Array size 1 for 1 bar
   if(CopyRates(_Symbol, _Period, 1, 1, rates) < 1) // Get data for the just closed candle (index 1)
   {
      PrintFormat("ProcessNewBarSignals: Not enough history to get rates for bar 1. Rates copied: %d", CopyRates(_Symbol, _Period, 1, 1, rates));
      return;
   }
   datetime prevCandleTime = rates[0].time; 
   double prevCandleHigh = rates[0].high;
   double prevCandleLow = rates[0].low;
   double prevCandleOpen = rates[0].open; 
   double prevCandleClose = rates[0].close;
   double calculatedRange = prevCandleHigh - prevCandleLow;

   // PrintFormat("ProcessNewBarSignals: Checking bar at %s. H:%.5f, L:%.5f, O:%.5f, C:%.5f, Range:%.5f",
   //             TimeToString(prevCandleTime), prevCandleHigh, prevCandleLow, prevCandleOpen, prevCandleClose, calculatedRange);

   double semaforBuyValues[1];
   double semaforSellValues[1];

   // We are checking candle at index 1 (the one that just closed)
   if(CopyBuffer(hSemafor, SEMAFOR_BUY_ARROW_BUFFER, 1, 1, semaforBuyValues) < 1 ||
      CopyBuffer(hSemafor, SEMAFOR_SELL_ARROW_BUFFER, 1, 1, semaforSellValues) < 1)
   {
      Print("ProcessNewBarSignals: Failed to copy Semafor buffers for bar 1.");
      return;
   }
   // PrintFormat("ProcessNewBarSignals: Semafor Buffers for bar 1 - Buy: %.5f, Sell: %.5f", semaforBuyValues[0], semaforSellValues[0]);

   // Check for Bullish Semafor
   if(semaforBuyValues[0] != 0.0) // Semafor Buy Arrow found on previous candle
   {
      ResetSignalData(psArrowBullish); // Reset previous bullish signal data
      psArrowBullish.signalUsed = false;
      psArrowBullish.candleTime = prevCandleTime;
      psArrowBullish.triggerPrice = prevCandleLow; // Semafor appears at the Low
      psArrowBullish.candleRange = calculatedRange;
      if (psArrowBullish.candleRange > 0) // Avoid division by zero or nonsensical thresholds
      {
         psArrowBullish.thresholdPrice = NormalizeDouble(psArrowBullish.triggerPrice + (psArrowBullish.candleRange * InpRetracementPercent / 100.0), _Digits);
      } else {
         psArrowBullish.thresholdPrice = 0.0; // Invalid if no range
      }
      PrintFormat("ProcessNewBarSignals: Bullish Semafor DETECTED. Time: %s, TrigP: %.5f, Range: %.5f, ThrP: %.5f",
                  TimeToString(psArrowBullish.candleTime), psArrowBullish.triggerPrice, psArrowBullish.candleRange, psArrowBullish.thresholdPrice);
      // --- Visualization: Draw new retracement line if Semafor identified ---
      if(psArrowBullish.thresholdPrice > 0.0)
      {
         string uniqueLineName = "PS_Line_BULL_" + TimeToString(psArrowBullish.candleTime, TIME_MINUTES|TIME_SECONDS);
         datetime time1 = psArrowBullish.candleTime;
         datetime time2 = psArrowBullish.candleTime + (5 * PeriodSeconds(_Period));
         if(ObjectFind(0,uniqueLineName) != -1) ObjectDelete(0,uniqueLineName); // Should not happen with unique name, but safety
         if(ObjectCreate(0, uniqueLineName, OBJ_TREND, 0, time1, psArrowBullish.thresholdPrice, time2, psArrowBullish.thresholdPrice))
         {
            ObjectSetInteger(0, uniqueLineName, OBJPROP_COLOR, clrDeepSkyBlue);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_STYLE, STYLE_DOT);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_WIDTH, 5);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_RAY_RIGHT, false);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_BACK, true);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_TIME, (long)psArrowBullish.candleTime);
         }
      }
   }

   // Check for Bearish Semafor
   if(semaforSellValues[0] != 0.0) // Semafor Sell Arrow found on previous candle
   {
      ResetSignalData(psArrowBearish); // Reset previous bearish signal data
      psArrowBearish.signalUsed = false;
      psArrowBearish.candleTime = prevCandleTime;
      psArrowBearish.triggerPrice = prevCandleHigh; // Semafor appears at the High
      psArrowBearish.candleRange = calculatedRange;
      if (psArrowBearish.candleRange > 0)
      {
         psArrowBearish.thresholdPrice = NormalizeDouble(psArrowBearish.triggerPrice - (psArrowBearish.candleRange * InpRetracementPercent / 100.0), _Digits);
      } else {
         psArrowBearish.thresholdPrice = 0.0; // Invalid if no range
      }
      PrintFormat("ProcessNewBarSignals: Bearish Semafor DETECTED. Time: %s, TrigP: %.5f, Range: %.5f, ThrP: %.5f",
                  TimeToString(psArrowBearish.candleTime), psArrowBearish.triggerPrice, psArrowBearish.candleRange, psArrowBearish.thresholdPrice);
      // --- Visualization: Draw new retracement line if Semafor identified ---
      if(psArrowBearish.thresholdPrice > 0.0)
      {
         string uniqueLineName = "PS_Line_BEAR_" + TimeToString(psArrowBearish.candleTime, TIME_MINUTES|TIME_SECONDS);
         datetime time1 = psArrowBearish.candleTime;
         datetime time2 = psArrowBearish.candleTime + (5 * PeriodSeconds(_Period));
         if(ObjectFind(0,uniqueLineName) != -1) ObjectDelete(0,uniqueLineName); // Should not happen with unique name, but safety
         if(ObjectCreate(0, uniqueLineName, OBJ_TREND, 0, time1, psArrowBearish.thresholdPrice, time2, psArrowBearish.thresholdPrice))
         {
            ObjectSetInteger(0, uniqueLineName, OBJPROP_COLOR, clrOrangeRed);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_STYLE, STYLE_DOT);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_WIDTH, 5);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_RAY_RIGHT, false);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_BACK, true);
            ObjectSetInteger(0, uniqueLineName, OBJPROP_TIME, (long)psArrowBearish.candleTime);
         }
      }
   }
}
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   // PrintFormat("OnTick: Start Tick. Current Time: %s", TimeToString(TimeCurrent()));
   // Removed static Semafor identification variables

   //--- New Bar Detection
   datetime currentBarOpenTime = (datetime)SeriesInfoInteger(_Symbol, _Period, SERIES_LASTBAR_DATE);
   bool isNewBar = false;
   if(lastBarOpenTime != currentBarOpenTime)
     {
      lastBarOpenTime = currentBarOpenTime;
      hasTradedThisBar = false; // Reset global trade flag on new bar
      // Removed semaforBarIndex, semaforPriceLevel, prevCandleRange initializations
      
      // Reset static OnTick variables related to Semafor identification for the new bar - These were removed, psArrow* are global
      isNewBar = true;
      PrintFormat("OnTick: New Bar Detected. Time: %s. Resetting trade flags.", TimeToString(currentBarOpenTime));

      ProcessNewBarSignals(); // Process signals for the new bar

      //--- Visualization Management: Delete old lines (remains here) ---
      for(int i = ObjectsTotal(0, -1, OBJ_TREND) - 1; i >= 0; i--)
        {
         string objName = ObjectName(0, i, -1, OBJ_TREND);
         if(StringFind(objName, "PS_Line_") == 0) 
           {
            datetime lineBarTime = (datetime)ObjectGetInteger(0, objName, OBJPROP_TIME, 0);
            if(lineBarTime > 0 && iBarShift(_Symbol, _Period, lineBarTime, false) > 5)
              {
               ObjectDelete(0, objName);
              }
           }
        }
     } // End of isNewBar initial block

   //--- If a trade has already been executed for this bar's signal context, exit.
   //    Note: psArrowBullish/Bearish.signalUsed flags are now primary for specific signal usage.
   //    hasTradedThisBar is a more general "traded on this bar" flag, might need refinement
   //    if multiple distinct signals could appear and be traded on the same bar (unlikely with this design).
   if(hasTradedThisBar)
     {
       // Print("OnTick: hasTradedThisBar is true. Waiting for next bar/signal opportunity.");
       // Still proceed to exit logic
     }

   // Fetch current prices for entry evaluation
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   if(ask == 0 || bid == 0)
     {
      Print("OnTick: Invalid Ask/Bid prices. Cannot proceed.");
      return;
     }
   // PrintFormat("OnTick: Current Ask: %.5f, Bid: %.5f", ask, bid);

   // --- Check for Bullish Entry ---
   PrintFormat("OnTick: Checking Bullish. psArrowBullish.candleTime: %s, signalUsed: %d, thresholdPrice: %.5f, hasTradedThisBar: %d",
               TimeToString(psArrowBullish.candleTime), (int)psArrowBullish.signalUsed, psArrowBullish.thresholdPrice, (int)hasTradedThisBar);
   if(psArrowBullish.candleTime > 0 && !psArrowBullish.signalUsed && psArrowBullish.thresholdPrice > 0.0 && !hasTradedThisBar)
     {
      PrintFormat("OnTick: Bullish Signal Active. Ask: %.5f, Threshold: %.5f", ask, psArrowBullish.thresholdPrice);
      if(ask >= psArrowBullish.thresholdPrice) // Price must move UP to or through the threshold
        {
         Print("OnTick: Bullish Retracement condition met.");
         bool tsiConfirmed = false; 
         bool macdConfirmed = false; // Ensure macdConfirmed is declared here
         // --- ComboTSI Confirmation (current candle - shift 0) ---
         double comboSignalValue[1];
         if(CopyBuffer(hComboTSI, COMBOTSI_SIGNAL_BUFFER, 0, 1, comboSignalValue) > 0)
           {
            double signal = comboSignalValue[0];
            if(InpComboTSISignalType == Strong_Only && signal == 0) tsiConfirmed = true; 
            else if(InpComboTSISignalType == Strong_And_Weak && (signal == 0 || signal == 2)) tsiConfirmed = true;
           }
         if(!tsiConfirmed) { Print("OnTick: Bullish TSI condition NOT MET."); }
         else { Print("OnTick: Bullish TSI Confirmed."); }
         // bool tsiConfirmed = true; // TEMPORARILY TRUE - This line must be removed.

         // --- 3. MACD Confirmation (Continuous State using Standard iMACD) ---
         PrintFormat("OnTick: Evaluating MACD State for Bullish Entry.");
         // macdConfirmed is already declared and initialized to false above
         double macdMainLine_B[1]; 
         double macdSignalLine_B[1];

         if(CopyBuffer(hStandardMACD, MAIN_LINE, 0, 1, macdMainLine_B) > 0 &&
            CopyBuffer(hStandardMACD, SIGNAL_LINE, 0, 1, macdSignalLine_B) > 0)
         {
             PrintFormat("OnTick: MACD State (Bullish Entry) - Main: %.5f, Signal: %.5f", macdMainLine_B[0], macdSignalLine_B[0]);
             if(macdMainLine_B[0] > macdSignalLine_B[0])
             {
                 macdConfirmed = true;
                 Print("OnTick: Bullish MACD State Confirmed (Main > Signal).");
             }
             else
             {
                 Print("OnTick: Bullish MACD State NOT Confirmed (Main <= Signal).");
             }
         }
         else
         {
             Print("OnTick: Failed to copy standard MACD lines for Bullish Entry check.");
         }
         // The existing 'if(tsiConfirmed && macdConfirmed)' will handle progression

         if(tsiConfirmed && macdConfirmed)
           {
            Print("OnTick: All Bullish conditions met. Proceeding with trade setup.");
            double lotSizeToUse = InpLotSize;
            if (InpLotSize <= 0.009) // Dynamic lot calculation
            {
                double balance = AccountInfoDouble(ACCOUNT_BALANCE);
                lotSizeToUse = NormalizeDouble(balance / 1000.0, GetLotDigits());
                double min_lot_dyn = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
                double max_lot_dyn = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
                double lot_step_dyn = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
                // PrintFormat("OnTick: Dynamic lot calc (Buy): Initial=%.2f, Min=%.2f, Max=%.2f, Step=%.2f", lotSizeToUse, min_lot_dyn, max_lot_dyn, lot_step_dyn);
                if (lotSizeToUse < min_lot_dyn) lotSizeToUse = min_lot_dyn;
                if (lotSizeToUse > max_lot_dyn) lotSizeToUse = max_lot_dyn;
                if (lot_step_dyn > 0) lotSizeToUse = floor(lotSizeToUse / lot_step_dyn) * lot_step_dyn;
                lotSizeToUse = NormalizeDouble(lotSizeToUse, GetLotDigits());
                // PrintFormat("OnTick: Dynamic lot calc (Buy): Adjusted=%.2f", lotSizeToUse);
            }
            if (lotSizeToUse < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN))
            {
                PrintFormat("OnTick: Lot size %.2f is less than SYMBOL_VOLUME_MIN %.2f. Skipping BUY trade.", lotSizeToUse, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN));
            }
            else
            {
               CTrade trade;
               trade.SetExpertMagicNumber(InpMagicNumber);
               trade.SetDeviationInPoints(3);
               trade.SetTypeFillingBySymbol(_Symbol);
               double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
               double slPrice = 0;
               if(InpStopLossPoints > 0) slPrice = NormalizeDouble(psArrowBullish.triggerPrice - InpStopLossPoints * point, _Digits);
               double tpPrice = 0;
               if(InpTakeProfitPoints > 0) tpPrice = NormalizeDouble(ask + InpTakeProfitPoints * point, _Digits);
               PrintFormat("OnTick: Preparing BUY. Lots: %.2f, Symbol: %s, Price: %.5f, SL: %.5f, TP: %.5f, Magic: %d",
                           lotSizeToUse, _Symbol, ask, slPrice, tpPrice, InpMagicNumber);
               if(trade.Buy(lotSizeToUse, _Symbol, ask, slPrice, tpPrice, "PerfectScalp Buy"))
                 {
                  PrintFormat("OnTick: BUY order PLACED. ReqPrice: %.5f, ActualPrice: %.5f, SL: %.5f, TP: %.5f, Deal: %d, Retcode: %d",
                              ask, trade.ResultPrice(), slPrice, tpPrice, trade.ResultDeal(), trade.ResultRetcode());
                  psArrowBullish.signalUsed = true;
                  hasTradedThisBar = true;
                 }
               else
                 {
                  PrintFormat("OnTick: BUY order FAILED. Error: %d, Retcode: %d. Price: %.5f, SL: %.5f, TP: %.5f",
                              trade.ResultDeal(), trade.ResultRetcode(), ask, slPrice, tpPrice);
                 }
            }
           }
        }
     }

   // --- Check for Bearish Entry ---
   PrintFormat("OnTick: Checking Bearish. psArrowBearish.candleTime: %s, signalUsed: %d, thresholdPrice: %.5f, hasTradedThisBar: %d",
               TimeToString(psArrowBearish.candleTime), (int)psArrowBearish.signalUsed, psArrowBearish.thresholdPrice, (int)hasTradedThisBar);
   if(psArrowBearish.candleTime > 0 && !psArrowBearish.signalUsed && psArrowBearish.thresholdPrice > 0.0 && !hasTradedThisBar)
     {
      PrintFormat("OnTick: Bearish Signal Active. Bid: %.5f, Threshold: %.5f", bid, psArrowBearish.thresholdPrice);
      if(bid <= psArrowBearish.thresholdPrice) // Price must move DOWN to or through the threshold
        {
         Print("OnTick: Bearish Retracement condition met.");
         bool tsiConfirmed = false;
         bool macdConfirmed = false; // Ensure macdConfirmed is declared here
         // --- ComboTSI Confirmation (current candle - shift 0) ---
         double comboSignalValue[1];
         if(CopyBuffer(hComboTSI, COMBOTSI_SIGNAL_BUFFER, 0, 1, comboSignalValue) > 0)
           {
            double signal = comboSignalValue[0];
            if(InpComboTSISignalType == Strong_Only && signal == 1) tsiConfirmed = true; 
            else if(InpComboTSISignalType == Strong_And_Weak && (signal == 1 || signal == 3)) tsiConfirmed = true;
           }
         if(!tsiConfirmed) { Print("OnTick: Bearish TSI condition NOT MET."); }
         else { Print("OnTick: Bearish TSI Confirmed."); }
         // bool tsiConfirmed = true; // TEMPORARILY TRUE - This line must be removed.

         // --- 3. MACD Confirmation (Continuous State using Standard iMACD) ---
         PrintFormat("OnTick: Evaluating MACD State for Bearish Entry.");
         // macdConfirmed is already declared and initialized to false above
         double macdMainLine_S[1]; 
         double macdSignalLine_S[1];

         if(CopyBuffer(hStandardMACD, MAIN_LINE, 0, 1, macdMainLine_S) > 0 &&
            CopyBuffer(hStandardMACD, SIGNAL_LINE, 0, 1, macdSignalLine_S) > 0)
         {
             PrintFormat("OnTick: MACD State (Bearish Entry) - Main: %.5f, Signal: %.5f", macdMainLine_S[0], macdSignalLine_S[0]);
             if(macdMainLine_S[0] < macdSignalLine_S[0])
             {
                 macdConfirmed = true;
                 Print("OnTick: Bearish MACD State Confirmed (Main < Signal).");
             }
             else
             {
                 Print("OnTick: Bearish MACD State NOT Confirmed (Main >= Signal).");
             }
         }
         else
         {
             Print("OnTick: Failed to copy standard MACD lines for Bearish Entry check.");
         }
         // The existing 'if(tsiConfirmed && macdConfirmed)' will handle progression
         
         if(tsiConfirmed && macdConfirmed)
           {
            Print("OnTick: All Bearish conditions met. Proceeding with trade setup.");
            double lotSizeToUse = InpLotSize;
            if (InpLotSize <= 0.009) // Dynamic lot calculation
            {
                double balance = AccountInfoDouble(ACCOUNT_BALANCE);
                lotSizeToUse = NormalizeDouble(balance / 1000.0, GetLotDigits());
                double min_lot_dyn = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
                double max_lot_dyn = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
                double lot_step_dyn = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
                // PrintFormat("OnTick: Dynamic lot calc (Sell): Initial=%.2f, Min=%.2f, Max=%.2f, Step=%.2f", lotSizeToUse, min_lot_dyn, max_lot_dyn, lot_step_dyn);
                if (lotSizeToUse < min_lot_dyn) lotSizeToUse = min_lot_dyn;
                if (lotSizeToUse > max_lot_dyn) lotSizeToUse = max_lot_dyn;
                if (lot_step_dyn > 0) lotSizeToUse = floor(lotSizeToUse / lot_step_dyn) * lot_step_dyn;
                lotSizeToUse = NormalizeDouble(lotSizeToUse, GetLotDigits());
                // PrintFormat("OnTick: Dynamic lot calc (Sell): Adjusted=%.2f", lotSizeToUse);
            }
            if (lotSizeToUse < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN))
            {
                PrintFormat("OnTick: Lot size %.2f is less than SYMBOL_VOLUME_MIN %.2f. Skipping SELL trade.", lotSizeToUse, SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN));
            }
            else
            {
               CTrade trade;
               trade.SetExpertMagicNumber(InpMagicNumber);
               trade.SetDeviationInPoints(3);
               trade.SetTypeFillingBySymbol(_Symbol);
               double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
               double slPrice = 0;
               if(InpStopLossPoints > 0) slPrice = NormalizeDouble(psArrowBearish.triggerPrice + InpStopLossPoints * point, _Digits);
               double tpPrice = 0;
               if(InpTakeProfitPoints > 0) tpPrice = NormalizeDouble(bid - InpTakeProfitPoints * point, _Digits);
               PrintFormat("OnTick: Preparing SELL. Lots: %.2f, Symbol: %s, Price: %.5f, SL: %.5f, TP: %.5f, Magic: %d",
                           lotSizeToUse, _Symbol, bid, slPrice, tpPrice, InpMagicNumber);
               if(trade.Sell(lotSizeToUse, _Symbol, bid, slPrice, tpPrice, "PerfectScalp Sell"))
                 {
                  PrintFormat("OnTick: SELL order PLACED. ReqPrice: %.5f, ActualPrice: %.5f, SL: %.5f, TP: %.5f, Deal: %d, Retcode: %d",
                              bid, trade.ResultPrice(), slPrice, tpPrice, trade.ResultDeal(), trade.ResultRetcode());
                  psArrowBearish.signalUsed = true;
                  hasTradedThisBar = true;
                 }
               else
                 {
                  PrintFormat("OnTick: SELL order FAILED. Error: %d, Retcode: %d. Price: %.5f, SL: %.5f, TP: %.5f",
                              trade.ResultDeal(), trade.ResultRetcode(), bid, slPrice, tpPrice);
                 }
            }
           }
        }
     }
   
   //--- Exit Condition Logic (check on every tick) ---
   int totalPositions = PositionsTotal();
   CTrade tradeExit; // Instantiate CTrade for closing positions
   tradeExit.SetExpertMagicNumber(InpMagicNumber); // Ensure it only closes its own trades

   for(int i = totalPositions - 1; i >= 0; i--)
     {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;

      if(PositionSelectByTicket(ticket))
        {
         if(PositionGetInteger(POSITION_MAGIC) == InpMagicNumber &&
            PositionGetString(POSITION_SYMBOL) == _Symbol)
           {
            ENUM_POSITION_TYPE positionType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            // Get current standard MACD state for exit confirmation
            double macdMainLine_Exit[1];
            double macdSignalLine_Exit[1];
            bool closeSignal = false; // Initialize closeSignal for this position
            string closeReason = "";  // Initialize closeReason

            if(CopyBuffer(hStandardMACD, MAIN_LINE, 0, 1, macdMainLine_Exit) > 0 &&
               CopyBuffer(hStandardMACD, SIGNAL_LINE, 0, 1, macdSignalLine_Exit) > 0)
            {
                PrintFormat("OnTick: Exit Logic for Position #%d (%s) - MACD Main: %.5f, Signal: %.5f",
                            ticket, EnumToString(positionType), macdMainLine_Exit[0], macdSignalLine_Exit[0]);

                if(positionType == POSITION_TYPE_BUY && macdMainLine_Exit[0] < macdSignalLine_Exit[0]) 
                {
                    closeSignal = true;
                    closeReason = "MACD Main < Signal (Continuous State)";
                    PrintFormat("OnTick: Exit Signal for BUY Position #%d due to %s.", ticket, closeReason);
                }
                else if(positionType == POSITION_TYPE_SELL && macdMainLine_Exit[0] > macdSignalLine_Exit[0])
                {
                    closeSignal = true;
                    closeReason = "MACD Main > Signal (Continuous State)";
                    PrintFormat("OnTick: Exit Signal for SELL Position #%d due to %s.", ticket, closeReason);
                }
                else
                {
                    // No MACD-based exit signal for this position based on continuous state
                    // PrintFormat("OnTick: Exit Logic - Position #%d (%s): No MACD state change for exit. Main: %.5f, Signal: %.5f", 
                    //             ticket, EnumToString(positionType), macdMainLine_Exit[0], macdSignalLine_Exit[0]); // Optional: can be noisy
                }
            }
            else
            {
                PrintFormat("OnTick: Failed to copy standard MACD lines for Exit check on position #%d.", ticket);
                // continue; // Decide if we should skip closing attempt or proceed without MACD check if copy fails
                             // For now, if MACD copy fails, closeSignal remains false, so no MACD-based exit.
            }

            // The existing 'if(closeSignal)' block with 'tradeExit.PositionClose(ticket)' will use the new closeSignal.
            if(closeSignal)
                 {
                  if(tradeExit.PositionClose(ticket))
                    {
                     PrintFormat("Closed position #%d (%s) due to %s. Result: %d, Ret: %d",
                                 ticket, EnumToString(positionType), closeReason, tradeExit.ResultDeal(), tradeExit.ResultRetcode());
                     // Potentially reset hasTradedThisBar if you want to allow new entries on the same bar after an exit.
                     // For this EA, default is to wait for next bar.
                    }
                  else
                    {
                     PrintFormat("Failed to close position #%d (%s) for %s. Error: %d, Retcode: %d",
                                 ticket, EnumToString(positionType), closeReason, tradeExit.ResultDeal(), tradeExit.ResultRetcode());
                    }
                 }
              }
            else
              {
               // Print("Failed to copy MACD Crossover State for exit check on ticket: ", ticket);
               continue; 
              }
           }
        }
     }
//+------------------------------------------------------------------+
//| Custom functions (will be added later)                           |
//+------------------------------------------------------------------+

// End of PerfectScalp.mq5

